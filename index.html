<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>SYMPHONY BLASTER - By Faiz Sir</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;900&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            overflow: hidden;
            font-family: 'Orbitron', sans-serif;
            touch-action: none; /* Prevents scroll/zoom on mobile */
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(to bottom, #1a1a1a, #000);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* HUD */
        .hud-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ffcc;
            text-shadow: 0 0 10px #00ffcc;
            font-size: clamp(16px, 4vw, 24px);
            display: flex;
            gap: 20px;
            font-weight: bold;
            z-index: 5;
        }

        .level-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #ff00cc;
            text-shadow: 0 0 10px #ff00cc;
            font-size: clamp(16px, 4vw, 24px);
            font-weight: bold;
            z-index: 5;
        }

        /* Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 15, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            transition: opacity 0.3s;
            z-index: 20; /* Higher than HUD and Controls */
            backdrop-filter: blur(5px);
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
            display: none !important;
        }

        h1 {
            font-size: clamp(30px, 6vw, 60px);
            color: #00ffcc;
            text-transform: uppercase;
            letter-spacing: 5px;
            margin-bottom: 10px;
            text-shadow: 3px 3px 0px #ff00cc, -2px -2px 0px #00ccff;
            text-align: center;
            line-height: 1.2;
        }

        p {
            color: #ccc;
            font-size: clamp(14px, 3vw, 18px);
            margin-bottom: 30px;
            text-align: center;
            max-width: 600px;
            padding: 0 20px;
        }

        /* Buttons */
        .btn-grid {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            background: linear-gradient(45deg, #ff00cc, #333399);
            border: 2px solid #fff;
            padding: 15px 40px;
            color: white;
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            cursor: pointer;
            text-transform: uppercase;
            transition: transform 0.1s, box-shadow 0.2s;
            box-shadow: 0 0 15px rgba(255, 0, 204, 0.5);
            border-radius: 8px;
            min-width: 150px;
        }

        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(255, 0, 204, 0.8);
        }

        .btn:active {
            transform: scale(0.95);
        }

        .btn.secondary {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffcc;
            color: #00ffcc;
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.3);
        }
        
        /* Mobile Controls - SMALLER & FIXED */
        #mobile-controls {
            position: absolute;
            bottom: 10px; /* Kept very low */
            left: 0;
            width: 100%;
            height: 80px; /* Reduced container height */
            pointer-events: none;
            display: none; /* Hidden by default, JS controls this */
            padding: 0 15px;
            box-sizing: border-box;
            z-index: 15; /* Below screens but above game */
        }

        .d-pad { 
            position: absolute; 
            left: 10px; 
            bottom: 5px; 
            pointer-events: auto; 
        }
        
        .actions { 
            position: absolute; 
            right: 10px; 
            bottom: 5px; 
            pointer-events: auto; 
            display: flex; 
            gap: 15px;
        }

        .touch-btn {
            width: 55px; /* Reduced from 70px */
            height: 55px;
            background: rgba(0, 0, 0, 0.5); 
            border: 2px solid #00ffcc; /* Thinner border */
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #fff;
            font-size: 24px; /* Smaller font */
            backdrop-filter: blur(2px);
            user-select: none;
            touch-action: manipulation;
            box-shadow: 0 0 5px rgba(0, 255, 204, 0.3);
            transition: all 0.1s;
        }

        .touch-btn:active, .touch-btn.active {
            background: #00ffcc;
            color: #000;
            transform: scale(0.95);
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.6);
            opacity: 0.8;
        }

        .btn-shoot { 
            border-color: #ff00cc; 
            border-radius: 50%; 
        }
        
        .btn-shoot:active, .btn-shoot.active { 
            background: #ff00cc; 
            box-shadow: 0 0 15px rgba(255, 0, 204, 0.6);
        }

        .row { display: flex; gap: 10px; }
        
        /* Desktop Hint */
        #pc-hint {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            color: #666;
            font-size: 12px;
            pointer-events: none;
        }
    </style>
</head>
<body>
<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud-panel">
            <div id="score-display">SCORE: 0000</div>
            <div id="lives-display">♥ x 3</div>
        </div>
        <div class="level-indicator" id="level-display">LEVEL 1</div>

        <!-- Controls are now hidden by CSS display:none by default -->
        <div id="mobile-controls">
            <div class="d-pad">
                <div class="row">
                    <div class="touch-btn" id="btn-left">◄</div>
                    <div class="touch-btn" id="btn-right">►</div>
                </div>
            </div>
            <div class="actions">
                <div class="touch-btn btn-shoot" id="btn-shoot">●</div>
                <div class="touch-btn" id="btn-jump">▲</div>
            </div>
        </div>
    </div>

    <!-- Main Menu -->
    <div id="start-screen" class="screen">
        <h1>SYMPHONY BLASTER</h1>
        <p>A GAME BY FAIZ SIR<br><br>Jump on keys. Collect notes. Blast the static.</p>
        <button class="btn" id="btn-start-game">START GAME</button>
        <div id="pc-hint" style="position:relative; margin-top:20px; color:#888;">Controls: Arrows/WASD to Move • Space to Shoot</div>
    </div>

    <!-- Level Select -->
    <div id="level-screen" class="screen hidden">
        <h1>SELECT TRACK</h1>
        <p>Choose your difficulty</p>
        <div class="btn-grid">
            <button class="btn secondary" onclick="startGame(1)">TRACK 01<br><span style="font-size:12px">Andante (Easy)</span></button>
            <button class="btn secondary" onclick="startGame(2)">TRACK 02<br><span style="font-size:12px">Allegro (Medium)</span></button>
            <button class="btn secondary" onclick="startGame(3)">TRACK 03<br><span style="font-size:12px">Presto (Hard)</span></button>
        </div>
    </div>

    <!-- Game Over -->
    <div id="gameover-screen" class="screen hidden">
        <h1 id="go-title">GAME OVER</h1>
        <p id="go-score">Final Score: 0</p>
        <div class="btn-grid">
            <button class="btn" onclick="showLevelSelect()">REPLAY</button>
            <button class="btn secondary" onclick="location.reload()">MAIN MENU</button>
        </div>
    </div>
</div>

<script>
/* ----------------------
   Runner image preload
   ---------------------- */
const runnerImg = new Image();
runnerImg.crossOrigin = 'anonymous';
runnerImg.src = 'https://i.ibb.co/mr5S9JpY/file-00000000e11c71faa2b897c73b80e875.png';

/* ----------------------
   AUDIO ENGINE (Synthesizer)
   ---------------------- */
const AudioSys = {
    ctx: null,
    init() {
        if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        if (this.ctx.state === 'suspended') this.ctx.resume();
    },
    playTone(freq, type, dur, vol=0.1, slide=0) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        if(slide !== 0) osc.frequency.linearRampToValueAtTime(freq + slide, this.ctx.currentTime + dur);

        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + dur);

        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + dur);
    },
    sfxJump() { this.playTone(150, 'square', 0.2, 0.1, 150); },
    sfxShoot() { this.playTone(400, 'sawtooth', 0.1, 0.05, -200); },
    sfxCollect() {
        setTimeout(() => this.playTone(523.25, 'sine', 0.1, 0.1), 0);
        setTimeout(() => this.playTone(783.99, 'sine', 0.2, 0.1), 100);
    },
    sfxHit() { this.playTone(100, 'sawtooth', 0.3, 0.2, -50); },
    sfxWin() {
        [523, 659, 783, 1046].forEach((f, i) => setTimeout(() => this.playTone(f, 'square', 0.4, 0.1), i*150));
    },
    speak(text) {
        if('speechSynthesis' in window) {
            const u = new SpeechSynthesisUtterance(text);
            u.rate = 1.1; u.pitch = 0.9;
            window.speechSynthesis.speak(u);
        }
    }
};

/* ----------------------
   GAME ENGINE
   ---------------------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// State to track if user is on mobile/touch device
let isTouchDevice = false;

let GAME = {
    state: 'menu', // menu, playing, gameover
    width: 0, height: 0,
    gravity: 0.8,
    cameraX: 0,
    level: 1,
    score: 0,
    lives: 3,
    frame: 0
};

let KEYS = { left:false, right:false, up:false, shoot:false };

let entities = {
    player: null,
    platforms: [],
    enemies: [],
    bullets: [],
    particles: [],
    collectibles: [],
    decorations: [],
    goal: null
};

/* ----------------------
   CLASSES
   ---------------------- */
class Entity {
    constructor(x, y, w, h, c) {
        this.x = x; this.y = y; this.w = w; this.h = h; this.color = c;
        this.vx = 0; this.vy = 0;
        this.dead = false;
    }
    getBounds() { return {l:this.x, r:this.x+this.w, t:this.y, b:this.y+this.h}; }
    checkColl(o) {
        let a = this.getBounds(), b = o.getBounds();
        return a.l < b.r && a.r > b.l && a.t < b.b && a.b > b.t;
    }
}

class Player extends Entity {
    constructor(x, y) {
        super(x, y, 30, 40, '#00ffcc');
        this.speed = 6;
        this.jumpPow = -15;
        this.grounded = false;
        this.faceRight = true;
        this.cooldown = 0;
        this.invuln = 0;
    }
    update() {
        // Movement
        if (KEYS.left) { this.vx = -this.speed; this.faceRight = false; }
        else if (KEYS.right) { this.vx = this.speed; this.faceRight = true; }
        else { this.vx *= 0.8; } // Friction

        // Jump
        if (KEYS.up && this.grounded) {
            this.vy = this.jumpPow;
            this.grounded = false;
            AudioSys.sfxJump();
            spawnDust(this.x + this.w/2, this.y + this.h);
        }

        // Shoot
        if (KEYS.shoot && this.cooldown <= 0) {
            this.cooldown = 20;
            AudioSys.sfxShoot();
            entities.bullets.push(new Bullet(
                this.faceRight ? this.x + this.w : this.x - 15,
                this.y + 15,
                this.faceRight ? 12 : -12
            ));
        }
        if(this.cooldown > 0) this.cooldown--;
        if(this.invuln > 0) this.invuln--;

        // Physics
        this.vy += GAME.gravity;
        this.x += this.vx;
        this.y += this.vy;

        // Platform Collision
        this.grounded = false;
        entities.platforms.forEach(p => {
            if (this.vy >= 0 &&
                this.y + this.h <= p.y + p.h + this.vy && 
                this.y + this.h + this.vy >= p.y &&       
                this.x + this.w > p.x && this.x < p.x + p.w) {

                this.y = p.y - this.h;
                this.vy = 0;
                this.grounded = true;
            }
        });

        if (this.y > GAME.height + 100) {
            hurtPlayer(999);
        }

        if(this.x < 0) this.x = 0;
    }

    draw(camX) {
        if(this.invuln > 0 && Math.floor(Date.now()/100)%2===0) return;

        const img = runnerImg;
        const drawW = Math.max(this.w * 1.8, 48);
        const drawH = Math.max(this.h * 1.5, 48);
        const cx = this.x - camX + this.w / 2;
        const cy = this.y + this.h / 2;

        ctx.save();
        ctx.translate(cx, cy);
        ctx.scale(this.faceRight ? 1 : -1, 1);
        
        if (img.complete && img.naturalWidth !== 0) {
            ctx.drawImage(img, -drawW / 2, -drawH / 2, drawW, drawH);
        } else {
            ctx.fillStyle = this.color;
            ctx.fillRect(-this.w/2, -this.h/2, this.w, this.h);
            ctx.fillStyle = '#fff';
            ctx.fillRect(4, -10, 8, 4);
        }
        ctx.restore();
    }
}

class Bullet extends Entity {
    constructor(x, y, vx) {
        super(x, y, 15, 6, '#ff00cc');
        this.vx = vx;
        this.life = 60;
    }
    update() {
        this.x += this.vx;
        this.life--;
        if(this.life <= 0) this.dead = true;
    }
    draw(camX) {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x - camX, this.y, this.w, this.h);
        ctx.fillStyle = '#fff';
        ctx.fillRect(this.x - camX + 2, this.y+1, 8, 2);
    }
}

class Enemy extends Entity {
    constructor(x, y) {
        super(x, y, 40, 40, '#ff3333');
        this.startX = x;
        this.walkDist = 150;
        this.vx = -2;
        this.health = 2;
    }
    update() {
        this.x += this.vx;
        if(this.x < this.startX - this.walkDist) this.vx = 2;
        if(this.x > this.startX + this.walkDist) this.vx = -2;
    }
    draw(camX) {
        ctx.fillStyle = '#ff3333';
        ctx.fillRect(this.x - camX, this.y, this.w, this.h);
        ctx.fillStyle = '#222';
        ctx.beginPath();
        ctx.arc(this.x - camX + 12, this.y + 15, 5, 0, Math.PI*2);
        ctx.arc(this.x - camX + 28, this.y + 15, 5, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = '#222';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(this.x - camX + 5, this.y + 10);
        ctx.lineTo(this.x - camX + 15, this.y + 15);
        ctx.moveTo(this.x - camX + 35, this.y + 10);
        ctx.lineTo(this.x - camX + 25, this.y + 15);
        ctx.stroke();
    }
    takeDamage() {
        this.health--;
        if(this.health <= 0) {
            this.dead = true;
            GAME.score += 50;
            spawnExplosion(this.x + this.w/2, this.y + this.h/2);
            updateHUD();
        }
    }
}

class Note extends Entity {
    constructor(x, y) {
        super(x, y, 20, 30, '#ffff00');
        this.baseY = y;
        this.bobOffset = Math.random() * 100;
    }
    update() {
        this.y = this.baseY + Math.sin((GAME.frame + this.bobOffset) * 0.1) * 5;
    }
    draw(camX) {
        ctx.fillStyle = '#ffff00';
        ctx.font = 'bold 30px Arial';
        ctx.shadowColor = "#ffff00";
        ctx.shadowBlur = 10;
        ctx.fillText('♪', this.x - camX, this.y + 25);
        ctx.shadowBlur = 0;
    }
}

class Platform extends Entity {
    constructor(x, y, w) {
        super(x, y, w, 40, '#fff');
        this.isBlackKey = Math.random() > 0.6;
    }
    draw(camX) {
        if(this.isBlackKey) {
            ctx.fillStyle = '#111';
            ctx.fillRect(this.x - camX, this.y, this.w, this.h);
            ctx.fillStyle = '#333';
            ctx.fillRect(this.x - camX + 4, this.y + 4, this.w - 8, this.h - 8);
        } else {
            ctx.fillStyle = '#eee';
            ctx.fillRect(this.x - camX, this.y, this.w, this.h);
            ctx.fillStyle = '#ccc';
            ctx.fillRect(this.x - camX, this.y + this.h - 8, this.w, 8);
        }
    }
}

/* ----------------------
   CORE FUNCTIONS
   ---------------------- */
function init() {
    resize();
    window.addEventListener('resize', resize);
    
    window.addEventListener('keydown', e => handleKey(e, true));
    window.addEventListener('keyup', e => handleKey(e, false));

    document.getElementById('btn-start-game').onclick = () => {
        AudioSys.init();
        showScreen('level-screen');
    };

    // Detect touch capability initially
    if('ontouchstart' in window || navigator.maxTouchPoints > 0) {
        isTouchDevice = true;
        // Do NOT show controls yet. We wait for game start.
        setupTouch('btn-left', 'left');
        setupTouch('btn-right', 'right');
        setupTouch('btn-jump', 'up');
        setupTouch('btn-shoot', 'shoot');
    }

    loop();
}

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    GAME.width = canvas.width;
    GAME.height = canvas.height;
    ctx.imageSmoothingEnabled = false;
}

function handleKey(e, isDown) {
    const k = e.code;
    if(k==='ArrowLeft'||k==='KeyA') KEYS.left = isDown;
    if(k==='ArrowRight'||k==='KeyD') KEYS.right = isDown;
    if(k==='ArrowUp'||k==='KeyW'||k==='Space') KEYS.up = isDown;
    if(k==='KeyZ'||k==='KeyF'||k==='ControlLeft') KEYS.shoot = isDown;
}

function setupTouch(id, key) {
    const el = document.getElementById(id);
    const handleStart = (e) => { e.preventDefault(); KEYS[key] = true; el.classList.add('active'); };
    const handleEnd = (e) => { e.preventDefault(); KEYS[key] = false; el.classList.remove('active'); };
    
    el.addEventListener('touchstart', handleStart);
    el.addEventListener('touchend', handleEnd);
    el.addEventListener('mousedown', handleStart);
    el.addEventListener('mouseup', handleEnd);
    el.addEventListener('mouseout', handleEnd);
}

// Function to manage UI visibility
function toggleMobileControls(show) {
    const ctrl = document.getElementById('mobile-controls');
    if (show && isTouchDevice) {
        ctrl.style.display = 'block';
    } else {
        ctrl.style.display = 'none';
    }
}

function showScreen(id) {
    document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
    if(id) {
        // If showing a menu screen, HIDE controls
        document.getElementById(id).classList.remove('hidden');
        toggleMobileControls(false);
    } else {
        // If id is null (Game Playing), SHOW controls if mobile
        toggleMobileControls(true);
    }
}

function updateHUD() {
    document.getElementById('score-display').innerText = `SCORE: ${GAME.score.toString().padStart(4, '0')}`;
    document.getElementById('lives-display').innerText = `♥ x ${GAME.lives}`;
    document.getElementById('level-display').innerText = `LEVEL ${GAME.level}`;
}

function startGame(levelIdx) {
    GAME.level = levelIdx;
    GAME.state = 'playing';
    GAME.lives = 3;
    GAME.score = 0;
    GAME.frame = 0;
    KEYS = { left:false, right:false, up:false, shoot:false };
    
    updateHUD();
    showScreen(null); // This triggers toggleMobileControls(true)
    loadLevel(levelIdx);
    AudioSys.speak("Level " + levelIdx + ". Start.");
}

function loadLevel(lvl) {
    entities.player = new Player(100, 200);
    entities.platforms = [];
    entities.enemies = [];
    entities.collectibles = [];
    entities.bullets = [];
    entities.particles = [];
    entities.decorations = [];
    GAME.cameraX = 0;

    let length = 2000 + (lvl * 1500);
    let gapSize = (lvl === 1) ? 100 : (lvl === 2) ? 140 : 180;
    let enemyChance = 0.3 + (lvl * 0.15);

    let cx = 0;
    let cy = GAME.height - 150;

    entities.platforms.push(new Platform(0, cy, 400));
    cx += 400;

    while(cx < length) {
        cx += 60 + Math.random() * gapSize;
        let hChange = (Math.random() - 0.5) * 200;
        cy += hChange;
        
        if(cy > GAME.height - 100) cy = GAME.height - 150;
        if(cy < 200) cy = 300;

        let w = 150 + Math.random() * 200;
        entities.platforms.push(new Platform(cx, cy, w));

        if(Math.random() < enemyChance) {
            entities.enemies.push(new Enemy(cx + w/2 - 20, cy - 40));
        }

        if(Math.random() < 0.6) {
            let noteY = cy - 80 - Math.random()*80;
            entities.collectibles.push(new Note(cx + w/2, noteY));
        }

        cx += w;
    }

    entities.goal = { x: cx + 100, y: cy - 200, w: 60, h: 200 };
    entities.platforms.push(new Platform(cx, cy, 300));
}

function spawnDust(x, y) {
    for(let i=0; i<6; i++) {
        entities.particles.push({
            x: x, y: y, 
            vx: (Math.random()-0.5)*6, vy: (Math.random()-0.5)*6,
            life: 20 + Math.random()*20, color: '#fff', size: Math.random()*4
        });
    }
}

function spawnExplosion(x, y) {
    for(let i=0; i<10; i++) {
        entities.particles.push({
            x: x, y: y, 
            vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10,
            life: 30, color: '#ff3333', size: Math.random()*6
        });
    }
}

function hurtPlayer(dmg) {
    if(entities.player.invuln > 0) return;
    GAME.lives--;
    AudioSys.sfxHit();
    entities.player.invuln = 60;
    updateHUD();
    spawnExplosion(entities.player.x, entities.player.y);

    if(GAME.lives <= 0) {
        gameOver(false);
    } else {
        entities.player.vy = -15;
        if(entities.player.y > GAME.height) {
            entities.player.y = 100;
            entities.player.x = Math.max(0, entities.player.x - 300);
            entities.player.vx = 0;
            entities.player.vy = 0;
        }
    }
}

function gameOver(win) {
    GAME.state = 'gameover';
    KEYS.left = KEYS.right = KEYS.up = KEYS.shoot = false;
    
    // Explicitly hide mobile controls on Game Over
    toggleMobileControls(false);

    const title = document.getElementById('go-title');
    const score = document.getElementById('go-score');
    
    if(win) {
        title.innerText = "STAGE CLEARED!";
        title.style.color = "#00ffcc";
        AudioSys.sfxWin();
        AudioSys.speak("Stage Cleared!");
    } else {
        title.innerText = "GAME OVER";
        title.style.color = "#ff0033";
        AudioSys.speak("Game Over");
    }
    
    score.innerText = `FINAL SCORE: ${GAME.score}`;
    showScreen('gameover-screen');
}

function showLevelSelect() {
    showScreen('level-screen');
}

/* ----------------------
   MAIN LOOP
   ---------------------- */
function loop() {
    requestAnimationFrame(loop);

    if(GAME.state !== 'playing') return;

    GAME.frame++;
    const p = entities.player;

    p.update();

    let targetCamX = p.x - GAME.width * 0.3;
    if(targetCamX < 0) targetCamX = 0;
    GAME.cameraX += (targetCamX - GAME.cameraX) * 0.1;

    entities.bullets.forEach(b => b.update());
    entities.enemies.forEach(e => e.update());
    entities.collectibles.forEach(c => c.update());
    entities.particles.forEach(pt => {
        pt.x += pt.vx; pt.y += pt.vy; pt.life--;
    });

    entities.bullets = entities.bullets.filter(b => !b.dead && b.x < GAME.cameraX + GAME.width + 100);
    entities.particles = entities.particles.filter(pt => pt.life > 0);
    entities.enemies = entities.enemies.filter(e => !e.dead);
    entities.collectibles = entities.collectibles.filter(c => !c.dead);

    entities.bullets.forEach(b => {
        entities.enemies.forEach(e => {
            if(!b.dead && !e.dead && b.checkColl(e)) {
                b.dead = true;
                e.takeDamage();
            }
        });
    });

    entities.enemies.forEach(e => {
        if(p.checkColl(e)) {
            hurtPlayer(1);
        }
    });

    entities.collectibles.forEach(c => {
        if(p.checkColl(c)) {
            c.dead = true;
            GAME.score += 10;
            AudioSys.sfxCollect();
            updateHUD();
        }
    });

    if(p.x > entities.goal.x) {
        gameOver(true);
    }

    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = '#222';
    for(let i=0; i<20; i++) {
        let starX = ((i*100) - (GAME.cameraX * 0.5)) % GAME.width;
        if(starX < 0) starX += GAME.width;
        ctx.fillRect(starX, (i*35)%GAME.height, 4, 4);
    }

    entities.platforms.forEach(pl => pl.draw(GAME.cameraX));
    entities.enemies.forEach(e => e.draw(GAME.cameraX));
    entities.collectibles.forEach(c => c.draw(GAME.cameraX));
    entities.goal.w = 50;
    ctx.fillStyle = '#00ffcc';
    ctx.fillRect(entities.goal.x - GAME.cameraX, entities.goal.y, 10, 200);
    ctx.fillStyle = 'rgba(0, 255, 204, 0.3)';
    ctx.fillRect(entities.goal.x - GAME.cameraX + 10, entities.goal.y, 50, 200);

    entities.player.draw(GAME.cameraX);
    entities.bullets.forEach(b => b.draw(GAME.cameraX));

    entities.particles.forEach(pt => {
        ctx.fillStyle = pt.color;
        ctx.globalAlpha = pt.life / 20;
        ctx.fillRect(pt.x - GAME.cameraX, pt.y, pt.size, pt.size);
        ctx.globalAlpha = 1.0;
    });
}

init();
</script>
</body>
</html>


