<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <!-- viewport-fit=cover + safe-area handling for iOS/Android display cutouts -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <title> A GAME BY FAIZ SIR </title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;900&display=swap');

        :root {
            --control-size: 12vmin; /* scales with screen */
            --control-gap: 3vmin;
            --safe-bottom: env(safe-area-inset-bottom, 10px);
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #111;
            overflow: hidden;
            font-family: 'Orbitron', sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background-color: #1a1a1a;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* HUD */
        .hud-panel {
            position: absolute;
            top: calc(20px + env(safe-area-inset-top, 0px));
            left: 20px;
            color: #00ffcc;
            text-shadow: 0 0 10px #00ffcc;
            font-size: 20px;
            display: flex;
            gap: 20px;
            pointer-events: none;
        }

        .level-indicator {
            position: absolute;
            top: calc(20px + env(safe-area-inset-top, 0px));
            right: 20px;
            color: #ff00cc;
            text-shadow: 0 0 10px #ff00cc;
            font-size: 20px;
        }

        /* Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 15, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            transition: opacity 0.25s;
            z-index: 30;
            backdrop-filter: blur(4px);
            padding: 20px;
            box-sizing: border-box;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
            display: none !important;
        }

        h1 {
            font-size: 6vw;
            color: #00ffcc;
            text-transform: uppercase;
            letter-spacing: 5px;
            margin-bottom: 10px;
            text-shadow: 2px 2px 0px #ff00cc, -2px -2px 0px #00ccff;
            text-align: center;
        }

        p {
            color: #ccc;
            font-size: 1.1em;
            margin-bottom: 30px;
            text-align: center;
            max-width: 600px;
        }

        /* Buttons */
        .btn-grid {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            background: linear-gradient(45deg, #ff00cc, #333399);
            border: 2px solid #fff;
            padding: 12px 28px;
            color: white;
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            cursor: pointer;
            text-transform: uppercase;
            transition: transform 0.1s, box-shadow 0.2s;
            box-shadow: 0 0 15px rgba(255, 0, 204, 0.5);
            border-radius: 8px;
            min-width: 140px;
        }

        .btn:hover { transform: scale(1.04); }

        .btn.secondary {
            background: transparent;
            border: 2px solid #00ffcc;
            color: #00ffcc;
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.3);
        }
        
        /* Mobile Controls */
        #mobile-controls {
            position: fixed;
            left: 0;
            right: 0;
            bottom: calc(var(--safe-bottom));
            height: calc(var(--control-size) + 2 * var(--safe-bottom));
            pointer-events: none;
            display: none;
            padding: calc(0.5vmin + env(safe-area-inset-bottom, 5px));
            box-sizing: border-box;
            z-index: 100;
        }

        /* D-pad area (left) */
        .d-pad {
            position: absolute;
            left: 12px;
            bottom: calc(12px + env(safe-area-inset-bottom, 6px));
            pointer-events: auto;
            display: flex;
            gap: var(--control-gap);
            align-items: center;
            user-select: none;
        }

        /* Actions (right) */
        .actions {
            position: absolute;
            right: 12px;
            bottom: calc(12px + env(safe-area-inset-bottom, 6px));
            pointer-events: auto;
            display: flex;
            gap: calc(var(--control-gap) / 2);
            align-items: center;
        }

        .touch-btn {
            width: var(--control-size);
            height: var(--control-size);
            min-width: 48px;
            min-height: 48px;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(0, 255, 204, 0.18);
            border-radius: 14px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: rgba(0, 255, 204, 0.85);
            font-size: calc(var(--control-size) / 3);
            backdrop-filter: blur(3px);
            user-select: none;
            touch-action: manipulation;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }

        .touch-btn.active {
            background: rgba(0, 255, 204, 0.28);
            transform: scale(0.98);
            color: #fff;
        }

        .btn-shoot {
            border-color: rgba(255, 0, 204, 0.18);
            color: rgba(255, 0, 204, 0.85);
            border-radius: 50%;
        }
        .btn-shoot.active {
            background: rgba(255, 0, 204, 0.28);
        }

        /* small screens adjustments so things don't cut off */
        @media (max-width: 420px) {
            :root { --control-size: 14vmin; --control-gap: 2vmin; }
            .btn { min-width: 120px; padding: 10px 20px; font-size:16px; }
            h1 { font-size: 8vw; }
        }
    </style>
</head>
<body>
<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud-panel">
            <div id="score-display">SCORE: 0000</div>
            <div id="lives-display">♥ x 3</div>
        </div>
        <div class="level-indicator" id="level-display">LEVEL 1</div>

        <div id="mobile-controls">
            <div class="d-pad" id="dpad">
                <div class="touch-btn" id="btn-left">◄</div>
                <div style="width:calc(var(--control-gap));"></div>
                <div class="touch-btn" id="btn-right">►</div>
            </div>
            <div class="actions">
                <div class="touch-btn btn-shoot" id="btn-shoot">●</div>
                <div class="touch-btn" id="btn-jump">▲</div>
            </div>
        </div>
    </div>

    <!-- Main Menu -->
    <div id="start-screen" class="screen">
        <h1>SYMPHONY BLASTER</h1>
        <p>A rhythmic run & gun adventure.<br>Jump on keys. Collect notes. Blast the static.</p>
        <button class="btn" id="btn-start-game">START GAME</button>
    </div>

    <!-- Level Select -->
    <div id="level-screen" class="screen hidden">
        <h1>SELECT TRACK</h1>
        <p>Choose your difficulty</p>
        <div class="btn-grid">
            <button class="btn secondary" onclick="startGame(1)">TRACK 01<br><span style="font-size:12px">Andante (Easy)</span></button>
            <button class="btn secondary" onclick="startGame(2)">TRACK 02<br><span style="font-size:12px">Allegro (Medium)</span></button>
            <button class="btn secondary" onclick="startGame(3)">TRACK 03<br><span style="font-size:12px">Presto (Hard)</span></button>
        </div>
    </div>

    <!-- Game Over -->
    <div id="gameover-screen" class="screen hidden">
        <h1 id="go-title">GAME OVER</h1>
        <p id="go-score">Final Score: 0</p>
        <div class="btn-grid">
            <button class="btn" onclick="showLevelSelect()">REPLAY</button>
            <button class="btn secondary" onclick="location.reload()">MAIN MENU</button>
        </div>
    </div>
</div>

<script>
/* ----------------------
   Runner image preload
   ---------------------- */
const runnerImg = new Image();
runnerImg.crossOrigin = 'anonymous';
runnerImg.src = 'https://i.ibb.co/mr5S9JpY/file-00000000e11c71faa2b897c73b80e875.png';

/* ----------------------
   AUDIO ENGINE
   ---------------------- */
const AudioSys = {
    ctx: null,
    init() {
        if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        if (this.ctx.state === 'suspended') this.ctx.resume();
    },
    playTone(freq, type, dur, vol=0.1, slide=0) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        try {
            osc.type = type;
        } catch(e) { osc.type = 'sine'; }
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        if(slide !== 0) osc.frequency.linearRampToValueAtTime(freq + slide, this.ctx.currentTime + dur);

        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + dur);

        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + dur);
    },
    sfxJump() { this.playTone(150, 'square', 0.28, 0.08, 150); },
    sfxShoot() { this.playTone(400, 'sawtooth', 0.12, 0.05, -200); },
    sfxCollect() {
        setTimeout(() => this.playTone(523.25, 'sine', 0.08, 0.08), 0);
        setTimeout(() => this.playTone(659.25, 'sine', 0.08, 0.08), 50);
        setTimeout(() => this.playTone(783.99, 'sine', 0.12, 0.08), 100);
    },
    sfxHit() { this.playTone(100, 'sawtooth', 0.18, 0.08, -50); },
    speak(text) {
        if('speechSynthesis' in window) {
            const u = new SpeechSynthesisUtterance(text);
            u.rate = 1.2; u.pitch = 0.9;
            window.speechSynthesis.speak(u);
        }
    }
};

/* ----------------------
   GAME ENGINE
   ---------------------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let GAME = {
    state: 'menu', // menu, playing, gameover
    width: 0, height: 0,
    gravity: 0.6,
    cameraX: 0,
    level: 1,
    score: 0,
    lives: 3,
    frame: 0
};

let KEY_TIMESTAMPS = { up: 0 };
let KEYS = { left:false, right:false, up:false, shoot:false };

let entities = {
    player: null,
    platforms: [],
    enemies: [],
    bullets: [],
    particles: [],
    collectibles: [],
    decorations: [],
    goal: null
};

/* ----------------------
   CLASSES
   ---------------------- */
class Entity {
    constructor(x, y, w, h, c) {
        this.x = x; this.y = y; this.w = w; this.h = h; this.color = c;
        this.vx = 0; this.vy = 0;
        this.dead = false;
    }
    getBounds() { return {l:this.x, r:this.x+this.w, t:this.y, b:this.y+this.h}; }
    checkColl(o) {
        let a = this.getBounds(), b = o.getBounds();
        return a.l < b.r && a.r > b.l && a.t < b.b && a.b > b.t;
    }
}

class Player extends Entity {
    constructor(x, y) {
        super(x, y, 30, 30, '#00ffcc');
        this.speed = 6;
        this.jumpPow = -14;
        this.grounded = false;
        this.faceRight = true;
        this.cooldown = 0;
        this.invuln = 0;
        this.animFrame = 0;
    }
    performJump(strength=1.0) {
        if (!this.grounded) return false;
        this.vy = this.jumpPow * strength;
        this.grounded = false;
        AudioSys.sfxJump();
        spawnDust(this.x + 15, this.y + 30);
        return true;
    }
    update() {
        if (KEYS.left) { this.vx = -this.speed; this.faceRight = false; }
        else if (KEYS.right) { this.vx = this.speed; this.faceRight = true; }
        else { this.vx *= 0.8; }

        // (keyboard & touch jump handled by performJump calls)
        if (KEYS.shoot && this.cooldown <= 0) {
            this.cooldown = 15;
            AudioSys.sfxShoot();
            entities.bullets.push(new Bullet(
                this.faceRight ? this.x + this.w : this.x - 15,
                this.y + 10,
                this.faceRight ? 12 : -12
            ));
        }
        if(this.cooldown > 0) this.cooldown--;
        if(this.invuln > 0) this.invuln--;

        this.vy += GAME.gravity;
        this.x += this.vx;
        this.y += this.vy;

        // floor death
        if (this.y > GAME.height + 200) {
            hurtPlayer(999);
        }

        // platform land detection
        this.grounded = false;
        entities.platforms.forEach(p => {
            if (this.vy >= 0 &&
                this.y + this.h <= p.y + p.h + this.vy &&
                this.x + this.w > p.x && this.x < p.x + p.w) {

                if (this.y + this.h >= p.y) {
                    this.y = p.y - this.h;
                    this.vy = 0;
                    this.grounded = true;
                }
            }
        });

        if(this.x < 0) this.x = 0;
        this.animFrame++;
    }

    draw(camX) {
        if(this.invuln > 0 && Math.floor(Date.now()/100)%2===0) return;

        const img = runnerImg;
        const drawW = Math.max(this.w * 1.8, 48);
        const drawH = Math.max(this.h * 1.8, 48);
        const cx = this.x - camX + this.w / 2;
        const cy = this.y + this.h / 2;

        ctx.save();
        ctx.translate(cx, cy);
        ctx.scale(this.faceRight ? 1 : -1, 1);
        if (img.complete && img.naturalWidth !== 0) {
            ctx.drawImage(img, -drawW / 2, -drawH / 2, drawW, drawH);
        } else {
            ctx.fillStyle = this.color;
            ctx.fillRect(-this.w/2, -this.h/2, this.w, this.h);
        }
        ctx.restore();
    }
}

class Bullet extends Entity {
    constructor(x, y, vx) {
        super(x, y, 15, 5, '#ff00cc');
        this.vx = vx;
        this.life = 50;
    }
    update() {
        this.x += this.vx;
        this.life--;
        if(this.life <= 0) this.dead = true;
    }
    draw(camX) {
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.x - camX, this.y);
        ctx.lineTo(this.x - camX + (this.vx>0?15:-15), this.y);
        ctx.stroke();
    }
}

class Enemy extends Entity {
    constructor(x, y) {
        super(x, y, 35, 35, '#ff3333');
        this.startX = x;
        this.walkDist = 120;
        this.vx = -2;
    }
    update() {
        this.x += this.vx;
        if(this.x < this.startX - this.walkDist) this.vx = 2;
        if(this.x > this.startX + this.walkDist) this.vx = -2;
    }
    draw(camX) {
        ctx.fillStyle = '#ff3333';
        ctx.fillRect(this.x - camX, this.y, this.w, this.h);
        ctx.fillStyle = '#222';
        ctx.beginPath();
        ctx.arc(this.x - camX + 17.5, this.y + 17.5, 12, 0, Math.PI*2);
        ctx.fill();
        if(Math.floor(Date.now()/200)%2===0) {
            ctx.strokeStyle = '#ffaa00';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x - camX + 17.5, this.y + 17.5, 16, 0, Math.PI*2);
            ctx.stroke();
        }
    }
}

class Note extends Entity {
    constructor(x, y) {
        super(x, y, 20, 20, '#ffff00');
        this.baseY = y;
        this.bobOffset = Math.random() * 100;
    }
    update() {
        this.y = this.baseY + Math.sin((GAME.frame + this.bobOffset) * 0.1) * 6;
    }
    draw(camX) {
        ctx.fillStyle = '#ffff00';
        ctx.font = '24px Arial';
        ctx.fillText('♪', this.x - camX, this.y + 6);
    }
}

class Platform extends Entity {
    constructor(x, y, w) {
        super(x, y, w, 30, '#fff');
        this.isBlackKey = Math.random() > 0.7;
    }
    draw(camX) {
        if(this.isBlackKey) {
            ctx.fillStyle = '#222';
            ctx.fillRect(this.x - camX, this.y, this.w, this.h);
            ctx.fillStyle = '#444';
            ctx.fillRect(this.x - camX + 2, this.y + 2, this.w - 4, this.h - 10);
        } else {
            ctx.fillStyle = '#eee';
            ctx.fillRect(this.x - camX, this.y, this.w, this.h);
            ctx.fillStyle = '#ccc';
            ctx.fillRect(this.x - camX, this.y + this.h - 5, this.w, 5);
        }
    }
}

/* ----------------------
   CORE FUNCTIONS
   ---------------------- */
function init() {
    resize();
    window.addEventListener('resize', resize);

    // keyboard handling including press-duration for jump
    window.addEventListener('keydown', e => handleKey(e, true));
    window.addEventListener('keyup', e => handleKey(e, false));

    document.getElementById('btn-start-game').onclick = () => {
        AudioSys.init();
        AudioSys.speak("Select Track");
        showScreen('level-screen');
    };

    // set up touch/mouse controls
    setupTouch('btn-left', 'left');
    setupTouch('btn-right', 'right');
    setupTouch('btn-shoot', 'shoot');
    setupJumpTouch('btn-jump'); // special for long / short press

    // show mobile-controls on first touch
    function revealMobileControls() {
        document.getElementById('mobile-controls').style.display = 'block';
        window.removeEventListener('touchstart', revealMobileControls);
    }
    window.addEventListener('touchstart', revealMobileControls, {passive:true});

    requestAnimationFrame(loop);
}

function handleKey(e, isDown) {
    const k = e.code;
    // handle left/right/shoot simply
    if(k==='ArrowLeft'||k==='KeyA') { KEYS.left = isDown; e.preventDefault(); }
    if(k==='ArrowRight'||k==='KeyD') { KEYS.right = isDown; e.preventDefault(); }
    if(k==='KeyZ'||k==='KeyF'||k==='ControlLeft') { KEYS.shoot = isDown; }
    // handle up / space for jump with press-duration
    if(k==='ArrowUp' || k==='KeyW' || k==='Space') {
        if(isDown) {
            // key down start time
            if(KEY_TIMESTAMPS.up === 0) KEY_TIMESTAMPS.up = Date.now();
        } else {
            // key up -> compute duration and perform jump
            const down = KEY_TIMESTAMPS.up || 0;
            const duration = Date.now() - down;
            KEY_TIMESTAMPS.up = 0;
            performJumpByDuration(duration);
        }
        e.preventDefault();
    }
}

function performJumpByDuration(ms) {
    const p = entities.player;
    if(!p) return;
    const threshold = 300; // ms for long press
    if (ms >= threshold) {
        p.performJump(1.45); // high jump
    } else {
        p.performJump(1.0); // short jump
    }
}

/* Generic touch/mouse binder for left/right/shoot buttons */
function setupTouch(id, key) {
    const el = document.getElementById(id);
    if(!el) return;
    const onStart = (e) => { e.preventDefault(); KEYS[key] = true; el.classList.add('active'); };
    const onEnd = (e) => { e.preventDefault(); KEYS[key] = false; el.classList.remove('active'); };

    el.addEventListener('touchstart', onStart, {passive:false});
    el.addEventListener('touchend', onEnd, {passive:false});
    el.addEventListener('mousedown', onStart);
    window.addEventListener('mouseup', onEnd);
}

/* Special setup for jump button: detect long vs short press and call performJump immediately on release */
function setupJumpTouch(id) {
    const el = document.getElementById(id);
    if(!el) return;
    let startTime = 0;
    const onStart = (e) => {
        e.preventDefault();
        startTime = Date.now();
        el.classList.add('active');
    };
    const onEnd = (e) => {
        e.preventDefault();
        el.classList.remove('active');
        const duration = Date.now() - startTime;
        startTime = 0;
        performJumpByDuration(duration);
    };
    el.addEventListener('touchstart', onStart, {passive:false});
    el.addEventListener('touchend', onEnd, {passive:false});
    el.addEventListener('mousedown', onStart);
    window.addEventListener('mouseup', onEnd);
}

/* ----------------------
   LEVEL / ENTITIES
   ---------------------- */
function startGame(levelIdx) {
    AudioSys.init();
    GAME.level = levelIdx;
    GAME.state = 'playing';
    GAME.lives = 3;
    GAME.score = 0;
    updateHUD();
    showScreen(null);
    loadLevel(levelIdx);
    AudioSys.speak("Track " + levelIdx + " Start");
}

function loadLevel(lvl) {
    entities.player = new Player(100, 100);
    entities.platforms = [];
    entities.enemies = [];
    entities.collectibles = [];
    entities.bullets = [];
    entities.particles = [];
    entities.decorations = [];
    GAME.cameraX = 0;

    let length = 3000 + (lvl * 2000);
    let gapSize = (lvl === 1) ? 100 : (lvl === 2) ? 150 : 200;
    let enemyChance = 0.3 + (lvl * 0.1);

    let cx = 0;
    let cy = GAME.height - 100;

    entities.platforms.push(new Platform(0, cy, 400));
    cx += 400;

    while(cx < length) {
        cx += 50 + Math.random() * gapSize;
        let hChange = (Math.random() - 0.5) * 200;
        cy += hChange;
        if(cy > GAME.height - 50) cy = GAME.height - 100;
        if(cy < 200) cy = 300;

        let w = 100 + Math.random() * 200;
        entities.platforms.push(new Platform(cx, cy, w));

        if(Math.random() > 0.5) {
            entities.decorations.push({x: cx, y: cy - 200, type: 'staff'});
        }

        if(Math.random() < enemyChance) {
            entities.enemies.push(new Enemy(cx + w/2, cy - 35));
        }

        if(Math.random() < 0.5) {
            let noteY = cy - 80 - Math.random()*100;
            entities.collectibles.push(new Note(cx + w/2, noteY));
        }

        cx += w;
    }

    entities.goal = { x: length + 100, y: cy - 150, w: 40, h: 150 };
    entities.platforms.push(new Platform(length, cy, 300));
}

/* visuals / particles */
function spawnDust(x, y) {
    for(let i=0; i<8; i++) {
        entities.particles.push({
            x: x, y: y, vx: (Math.random()-0.5)*6, vy: (Math.random()-1.5)*4,
            life: 24 + Math.random()*20, color: '#fff'
        });
    }
}

/* ----------------------
   GAMEPLAY HELPERS
   ---------------------- */
function hurtPlayer(dmg) {
    if(!entities.player) return;
    if(entities.player.invuln > 0) return;
    GAME.lives--;
    AudioSys.sfxHit();
    entities.player.invuln = 60;
    updateHUD();

    if(GAME.lives <= 0) {
        gameOver();
    } else {
        entities.player.vy = -10;
        if(entities.player.y > GAME.height) {
            entities.player.y = 0;
            entities.player.x = Math.max(0, entities.player.x - 200);
            entities.player.vx = 0;
        }
    }
}

function collectNote(note) {
    GAME.score += 25;
    AudioSys.sfxCollect();
    note.dead = true;
    updateHUD();
}

function reachGoal() {
    AudioSys.sfxWin();
    GAME.score += 500;
    updateHUD();
    gameOver(true);
}

/* ----------------------
   RENDER / LOOP
   ---------------------- */
function loop() {
    GAME.frame++;
    update();
    draw();
    requestAnimationFrame(loop);
}

function update() {
    if(GAME.state !== 'playing') return;

    const p = entities.player;
    if(!p) return;

    // update entities
    entities.bullets.forEach(b => b.update());
    entities.enemies.forEach(e => e.update());
    entities.collectibles.forEach(n => n.update());
    entities.particles.forEach(pt => { pt.x += pt.vx; pt.y += pt.vy; pt.life--; pt.vy += 0.15; });

    // cleanup
    entities.bullets = entities.bullets.filter(b => !b.dead);
    entities.particles = entities.particles.filter(pt => pt.life > 0);
    entities.collectibles = entities.collectibles.filter(n => !n.dead);

    // player update
    p.update();

    // bullet hit enemy
    entities.bullets.forEach(b => {
        entities.enemies.forEach(en => {
            if(!b.dead && b.x > en.x && b.x < en.x + en.w && b.y > en.y && b.y < en.y + en.h) {
                b.dead = true;
                en.dead = true;
            }
        });
    });
    entities.enemies = entities.enemies.filter(e => !e.dead);

    // player collect notes
    entities.collectibles.forEach(n => {
        if(p.x < n.x + 20 && p.x + p.w > n.x - 8 && p.y < n.y + 20 && p.y + p.h > n.y - 8) {
            collectNote(n);
        }
    });

    // enemy collisions
    entities.enemies.forEach(en => {
        if(p.x + p.w > en.x && p.x < en.x + en.w && p.y + p.h > en.y && p.y < en.y + en.h) {
            // if player falling onto enemy (stomp)
            if(p.vy > 0 && p.y + p.h - en.y < 16) {
                en.dead = true;
                p.vy = -8;
                GAME.score += 50;
                updateHUD();
            } else {
                hurtPlayer(1);
            }
        }
    });

    // camera follow
    GAME.cameraX = Math.max(0, p.x - (GAME.width * 0.35));

    // goal check
    if(entities.goal && p.x > entities.goal.x) {
        reachGoal();
    }
}

function draw() {
    // resize canvas if needed (pixel ratio)
    if (canvas.width !== GAME.width || canvas.height !== GAME.height) {
        canvas.width = GAME.width;
        canvas.height = GAME.height;
    }

    // clear
    ctx.fillStyle = '#111';
    ctx.fillRect(0,0,GAME.width,GAME.height);

    // draw decorations background
    ctx.fillStyle = '#0b0b0b';
    ctx.fillRect(0, GAME.height - 160, GAME.width, 160);

    // platforms
    entities.platforms.forEach(pf => pf.draw(GAME.cameraX));

    // decorations (simple)
    entities.decorations.forEach(d => {
        if(d.type === 'staff') {
            ctx.fillStyle = '#555';
            ctx.fillRect(d.x - GAME.cameraX, d.y, 6, 120);
            ctx.fillStyle = '#777';
            ctx.fillRect(d.x - GAME.cameraX - 40, d.y + 10, 80, 2);
        }
    });

    // notes
    entities.collectibles.forEach(n => n.draw(GAME.cameraX));

    // enemies
    entities.enemies.forEach(e => e.draw(GAME.cameraX));

    // bullets
    entities.bullets.forEach(b => b.draw(GAME.cameraX));

    // player
    if(entities.player) entities.player.draw(GAME.cameraX);

    // particles
    entities.particles.forEach(pt => {
        ctx.fillStyle = pt.color;
        ctx.globalAlpha = Math.max(0, Math.min(1, pt.life / 40));
        ctx.fillRect(pt.x - GAME.cameraX, pt.y, 3, 3);
        ctx.globalAlpha = 1;
    });

    // goal marker
    if(entities.goal) {
        ctx.fillStyle = '#00ff88';
        ctx.fillRect(entities.goal.x - GAME.cameraX, entities.goal.y, entities.goal.w, entities.goal.h);
    }
}

/* ----------------------
   HUD & UI
   ---------------------- */
function updateHUD() {
    document.getElementById('score-display').textContent = 'SCORE: ' + String(GAME.score).padStart(4,'0');
    document.getElementById('lives-display').textContent = '♥ x ' + GAME.lives;
    document.getElementById('level-display').textContent = 'LEVEL ' + GAME.level;
}

function showScreen(screenId) {
    const screens = ['start-screen','level-screen','gameover-screen'];
    screens.forEach(s => {
        const el = document.getElementById(s);
        if(!el) return;
        if(screenId === null) el.classList.add('hidden'); // hide all
        else if(s === screenId) el.classList.remove('hidden');
        else el.classList.add('hidden');
    });
    if (screenId === null) {
        // hide overlays
        screens.forEach(s => document.getElementById(s)?.classList.add('hidden'));
        document.getElementById('mobile-controls').style.display = 'block';
    } else {
        document.getElementById('mobile-controls').style.display = 'none';
    }
}

function showLevelSelect() {
    showScreen('level-screen');
}

/* ----------------------
   GAME OVER
   ---------------------- */
function gameOver(win=false) {
    GAME.state = 'menu';
    const goTitle = document.getElementById('go-title');
    const goScore = document.getElementById('go-score');
    goTitle.textContent = win ? 'LEVEL COMPLETE!' : 'GAME OVER';
    goScore.textContent = 'Final Score: ' + GAME.score;
    showScreen('gameover-screen');
}

/* ----------------------
   RESIZE
   ---------------------- */
function resize() {
    const rect = document.getElementById('game-container').getBoundingClientRect();
    GAME.width = Math.max(320, Math.floor(rect.width));
    GAME.height = Math.max(240, Math.floor(rect.height));
    // scale control-size based on smallest dimension (CSS handles visual sizing)
    // ensure HUD updated
    updateHUD();
}

/* init after DOM ready */
window.addEventListener('load', () => {
    init();
    showScreen('start-screen');
});
</script>
</body>
</html>
