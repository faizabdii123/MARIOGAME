<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title> A GAME BY FAIZ SIR </title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;900&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #111;
            overflow: hidden;
            font-family: 'Orbitron', sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background-color: #1a1a1a;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* HUD */
        .hud-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ffcc;
            text-shadow: 0 0 10px #00ffcc;
            font-size: 20px;
            display: flex;
            gap: 20px;
        }

        .level-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #ff00cc;
            text-shadow: 0 0 10px #ff00cc;
            font-size: 20px;
        }

        /* Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 15, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            transition: opacity 0.3s;
            z-index: 10;
            backdrop-filter: blur(5px);
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
            display: none !important;
        }

        h1 {
            font-size: 4vw;
            color: #00ffcc;
            text-transform: uppercase;
            letter-spacing: 5px;
            margin-bottom: 10px;
            text-shadow: 2px 2px 0px #ff00cc, -2px -2px 0px #00ccff;
            text-align: center;
        }

        p {
            color: #ccc;
            font-size: 1.2em;
            margin-bottom: 30px;
            text-align: center;
            max-width: 600px;
        }

        /* Buttons */
        .btn-grid {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            background: linear-gradient(45deg, #ff00cc, #333399);
            border: 2px solid #fff;
            padding: 15px 40px;
            color: white;
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            cursor: pointer;
            text-transform: uppercase;
            transition: transform 0.1s, box-shadow 0.2s;
            box-shadow: 0 0 15px rgba(255, 0, 204, 0.5);
            border-radius: 5px;
            min-width: 150px;
        }

        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(255, 0, 204, 0.8);
        }

        .btn.secondary {
            background: transparent;
            border: 2px solid #00ffcc;
            color: #00ffcc;
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.3);
        }
        
        /* Mobile Controls - UPDATED */
        #mobile-controls {
            position: absolute;
            bottom: 0; /* Anchored to very bottom */
            left: 0;
            width: 100%;
            height: 100px; /* Reduced height to keep it low */
            pointer-events: none;
            display: none;
            padding: 0 10px;
            box-sizing: border-box;
            z-index: 100;
        }

        .d-pad { 
            position: absolute; 
            left: 10px; 
            bottom: 10px; 
            pointer-events: auto; 
        }
        
        .actions { 
            position: absolute; 
            right: 10px; 
            bottom: 10px; 
            pointer-events: auto; 
            display: flex; 
            gap: 15px;
        }

        .touch-btn {
            width: 65px;
            height: 65px;
            background: rgba(255, 255, 255, 0.1); /* Very transparent */
            border: 1px solid rgba(0, 255, 204, 0.3); /* Subtle border */
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: rgba(0, 255, 204, 0.7);
            font-size: 24px;
            backdrop-filter: blur(2px);
            user-select: none;
            touch-action: manipulation;
        }

        .touch-btn.active {
            background: rgba(0, 255, 204, 0.3);
            transform: scale(0.95);
            color: #fff;
        }

        .btn-shoot { 
            border-color: rgba(255, 0, 204, 0.3); 
            color: rgba(255, 0, 204, 0.7); 
            border-radius: 50%; 
        }
        .btn-shoot.active { 
            background: rgba(255, 0, 204, 0.3); 
        }

        .row { display: flex; gap: 10px; }
    </style>
</head>
<body>
<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud-panel">
            <div id="score-display">SCORE: 0000</div>
            <div id="lives-display">♥ x 3</div>
        </div>
        <div class="level-indicator" id="level-display">LEVEL 1</div>

        <div id="mobile-controls">
            <div class="d-pad">
                <div class="row">
                    <div class="touch-btn" id="btn-left">◄</div>
                    <div class="touch-btn" id="btn-right">►</div>
                </div>
            </div>
            <div class="actions">
                <div class="touch-btn btn-shoot" id="btn-shoot">●</div>
                <div class="touch-btn" id="btn-jump">▲</div>
            </div>
        </div>
    </div>

    <!-- Main Menu -->
    <div id="start-screen" class="screen">
        <h1>SYMPHONY BLASTER</h1>
        <p>A rhythmic run & gun adventure.<br>Jump on keys. Collect notes. Blast the static.</p>
        <button class="btn" id="btn-start-game">START GAME</button>
    </div>

    <!-- Level Select -->
    <div id="level-screen" class="screen hidden">
        <h1>SELECT TRACK</h1>
        <p>Choose your difficulty</p>
        <div class="btn-grid">
            <button class="btn secondary" onclick="startGame(1)">TRACK 01<br><span style="font-size:12px">Andante (Easy)</span></button>
            <button class="btn secondary" onclick="startGame(2)">TRACK 02<br><span style="font-size:12px">Allegro (Medium)</span></button>
            <button class="btn secondary" onclick="startGame(3)">TRACK 03<br><span style="font-size:12px">Presto (Hard)</span></button>
        </div>
    </div>

    <!-- Game Over -->
    <div id="gameover-screen" class="screen hidden">
        <h1 id="go-title">GAME OVER</h1>
        <p id="go-score">Final Score: 0</p>
        <div class="btn-grid">
            <button class="btn" onclick="showLevelSelect()">REPLAY</button>
            <button class="btn secondary" onclick="location.reload()">MAIN MENU</button>
        </div>
    </div>
</div>

<script>
/* ----------------------
   Runner image preload
   ---------------------- */
const runnerImg = new Image();
runnerImg.crossOrigin = 'anonymous';
runnerImg.src = 'https://i.ibb.co/mr5S9JpY/file-00000000e11c71faa2b897c73b80e875.png';

/* ----------------------
   AUDIO ENGINE (Synthesizer)
   ---------------------- */
const AudioSys = {
    ctx: null,
    init() {
        if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        if (this.ctx.state === 'suspended') this.ctx.resume();
    },
    playTone(freq, type, dur, vol=0.1, slide=0) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        if(slide !== 0) osc.frequency.linearRampToValueAtTime(freq + slide, this.ctx.currentTime + dur);

        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + dur);

        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + dur);
    },
    sfxJump() { this.playTone(150, 'square', 0.3, 0.1, 150); },
    sfxShoot() { this.playTone(400, 'sawtooth', 0.15, 0.05, -200); },
    sfxCollect() {
        setTimeout(() => this.playTone(523.25, 'sine', 0.1, 0.1), 0);
        setTimeout(() => this.playTone(659.25, 'sine', 0.1, 0.1), 50);
        setTimeout(() => this.playTone(783.99, 'sine', 0.2, 0.1), 100);
    },
    sfxHit() { this.playTone(100, 'sawtooth', 0.2, 0.1, -50); },
    sfxWin() {
        [523, 659, 783, 1046].forEach((f, i) => setTimeout(() => this.playTone(f, 'square', 0.4, 0.1), i*150));
    },
    speak(text) {
        if('speechSynthesis' in window) {
            const u = new SpeechSynthesisUtterance(text);
            u.rate = 1.2; u.pitch = 0.9;
            window.speechSynthesis.speak(u);
        }
    }
};

/* ----------------------
   GAME ENGINE
   ---------------------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let GAME = {
    state: 'menu', // menu, playing, gameover
    width: 0, height: 0,
    gravity: 0.6,
    cameraX: 0,
    level: 1,
    score: 0,
    lives: 3,
    frame: 0
};

let KEYS = { left:false, right:false, up:false, shoot:false };

let entities = {
    player: null,
    platforms: [],
    enemies: [],
    bullets: [],
    particles: [],
    collectibles: [],
    decorations: [],
    goal: null
};

/* ----------------------
   CLASSES
   ---------------------- */
class Entity {
    constructor(x, y, w, h, c) {
        this.x = x; this.y = y; this.w = w; this.h = h; this.color = c;
        this.vx = 0; this.vy = 0;
        this.dead = false;
    }
    getBounds() { return {l:this.x, r:this.x+this.w, t:this.y, b:this.y+this.h}; }
    checkColl(o) {
        let a = this.getBounds(), b = o.getBounds();
        return a.l < b.r && a.r > b.l && a.t < b.b && a.b > b.t;
    }
}

class Player extends Entity {
    constructor(x, y) {
        super(x, y, 30, 30, '#00ffcc');
        this.speed = 6;
        this.jumpPow = -14;
        this.grounded = false;
        this.faceRight = true;
        this.cooldown = 0;
        this.invuln = 0;
        this.animFrame = 0;
    }
    update() {
        if (KEYS.left) { this.vx = -this.speed; this.faceRight = false; }
        else if (KEYS.right) { this.vx = this.speed; this.faceRight = true; }
        else { this.vx *= 0.8; }

        if (KEYS.up && this.grounded) {
            this.vy = this.jumpPow;
            this.grounded = false;
            AudioSys.sfxJump();
            spawnDust(this.x + 15, this.y + 30);
        }

        if (KEYS.shoot && this.cooldown <= 0) {
            this.cooldown = 15;
            AudioSys.sfxShoot();
            entities.bullets.push(new Bullet(
                this.faceRight ? this.x + this.w : this.x - 15,
                this.y + 10,
                this.faceRight ? 12 : -12
            ));
        }
        if(this.cooldown > 0) this.cooldown--;
        if(this.invuln > 0) this.invuln--;

        this.vy += GAME.gravity;
        this.x += this.vx;
        this.y += this.vy;

        this.grounded = false;
        if (this.y + this.h > GAME.height) {
            hurtPlayer(999);
        }

        entities.platforms.forEach(p => {
            if (this.vy >= 0 &&
                this.y + this.h <= p.y + p.h + this.vy &&
                this.x + this.w > p.x && this.x < p.x + p.w) {

                if (this.y + this.h >= p.y) {
                    this.y = p.y - this.h;
                    this.vy = 0;
                    this.grounded = true;
                }
            }
        });

        if(this.x < 0) this.x = 0;
        this.animFrame++;
    }

    draw(camX) {
        if(this.invuln > 0 && Math.floor(Date.now()/100)%2===0) return;

        const img = runnerImg;
        const drawW = Math.max(this.w * 1.8, 48);
        const drawH = Math.max(this.h * 1.8, 48);
        const cx = this.x - camX + this.w / 2;
        const cy = this.y + this.h / 2;

        ctx.save();
        ctx.translate(cx, cy);
        ctx.scale(this.faceRight ? 1 : -1, 1);
        if (img.complete && img.naturalWidth !== 0) {
            ctx.drawImage(img, -drawW / 2, -drawH / 2, drawW, drawH);
        } else {
            ctx.fillStyle = this.color;
            ctx.fillRect(-this.w/2, -this.h/2, this.w, this.h);
        }
        ctx.restore();
    }
}

class Bullet extends Entity {
    constructor(x, y, vx) {
        super(x, y, 15, 5, '#ff00cc');
        this.vx = vx;
        this.life = 50;
    }
    update() {
        this.x += this.vx;
        this.life--;
        if(this.life <= 0) this.dead = true;
    }
    draw(camX) {
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.x - camX, this.y);
        ctx.lineTo(this.x - camX + (this.vx>0?15:-15), this.y);
        ctx.stroke();
    }
}

class Enemy extends Entity {
    constructor(x, y) {
        super(x, y, 35, 35, '#ff3333');
        this.startX = x;
        this.walkDist = 120;
        this.vx = -2;
    }
    update() {
        this.x += this.vx;
        if(this.x < this.startX - this.walkDist) this.vx = 2;
        if(this.x > this.startX + this.walkDist) this.vx = -2;
    }
    draw(camX) {
        ctx.fillStyle = '#ff3333';
        ctx.fillRect(this.x - camX, this.y, this.w, this.h);
        ctx.fillStyle = '#222';
        ctx.beginPath();
        ctx.arc(this.x - camX + 17.5, this.y + 17.5, 12, 0, Math.PI*2);
        ctx.fill();
        if(Math.floor(Date.now()/200)%2===0) {
            ctx.strokeStyle = '#ffaa00';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x - camX + 17.5, this.y + 17.5, 16, 0, Math.PI*2);
            ctx.stroke();
        }
    }
}

class Note extends Entity {
    constructor(x, y) {
        super(x, y, 20, 20, '#ffff00');
        this.bobOffset = Math.random() * 100;
    }
    update() {
        // bobbing
        // small vertical oscillation around original y is fine — but since we modify y directly during generation we store a base
        this.y += Math.sin((GAME.frame + this.bobOffset) * 0.1) * 0.2;
    }
    draw(camX) {
        ctx.fillStyle = '#ffff00';
        ctx.font = '24px Arial';
        ctx.fillText('♪', this.x - camX, this.y + 20);
    }
}

class Platform extends Entity {
    constructor(x, y, w) {
        super(x, y, w, 30, '#fff');
        this.isBlackKey = Math.random() > 0.7;
    }
    draw(camX) {
        if(this.isBlackKey) {
            ctx.fillStyle = '#222';
            ctx.fillRect(this.x - camX, this.y, this.w, this.h);
            ctx.fillStyle = '#444';
            ctx.fillRect(this.x - camX + 2, this.y + 2, this.w - 4, this.h - 10);
        } else {
            ctx.fillStyle = '#eee';
            ctx.fillRect(this.x - camX, this.y, this.w, this.h);
            ctx.fillStyle = '#ccc';
            ctx.fillRect(this.x - camX, this.y + this.h - 5, this.w, 5);
        }
    }
}

/* ----------------------
   CORE FUNCTIONS
   ---------------------- */
function init() {
    resize();
    window.addEventListener('resize', resize);

    window.addEventListener('keydown', e => handleKey(e, true));
    window.addEventListener('keyup', e => handleKey(e, false));

    document.getElementById('btn-start-game').onclick = () => {
        AudioSys.init();
        AudioSys.speak("Select Track");
        showScreen('level-screen');
    };

    setupTouch('btn-left', 'left');
    setupTouch('btn-right', 'right');
    setupTouch('btn-jump', 'up');
    setupTouch('btn-shoot', 'shoot');

    window.addEventListener('touchstart', function onTouch() {
        document.getElementById('mobile-controls').style.display = 'block';
        window.removeEventListener('touchstart', onTouch);
    });

    // quick mobile detection: if touch enabled show mobile controls button area but keep pointer-events none until touched
    if('ontouchstart' in window) {
        // leave hidden until first touch (handled above)
    }

    requestAnimationFrame(loop);
}

function handleKey(e, isDown) {
    const k = e.code;
    if(k==='ArrowLeft'||k==='KeyA') KEYS.left = isDown;
    if(k==='ArrowRight'||k==='KeyD') KEYS.right = isDown;
    if(k==='ArrowUp'||k==='KeyW'||k==='Space') KEYS.up = isDown;
    if(k==='KeyZ'||k==='KeyF'||k==='ControlLeft') KEYS.shoot = isDown;
}

function setupTouch(id, key) {
    const el = document.getElementById(id);
    el.addEventListener('touchstart', e => { e.preventDefault(); KEYS[key] = true; el.classList.add('active'); });
    el.addEventListener('touchend', e => { e.preventDefault(); KEYS[key] = false; el.classList.remove('active'); });
    // support mouse for desktop testing
    el.addEventListener('mousedown', e => { e.preventDefault(); KEYS[key] = true; el.classList.add('active'); });
    window.addEventListener('mouseup', e => { KEYS[key] = false; el.classList.remove('active'); });
}

function startGame(levelIdx) {
    GAME.level = levelIdx;
    GAME.state = 'playing';
    GAME.lives = 3;
    GAME.score = 0;
    updateHUD();
    showScreen(null);
    loadLevel(levelIdx);
    AudioSys.speak("Track " + levelIdx + " Start");
}

function loadLevel(lvl) {
    entities.player = new Player(100, 100);
    entities.platforms = [];
    entities.enemies = [];
    entities.collectibles = [];
    entities.bullets = [];
    entities.particles = [];
    entities.decorations = [];
    GAME.cameraX = 0;

    let length = 3000 + (lvl * 2000);
    let gapSize = (lvl === 1) ? 100 : (lvl === 2) ? 150 : 200;
    let enemyChance = 0.3 + (lvl * 0.1);

    let cx = 0;
    let cy = GAME.height - 100;

    entities.platforms.push(new Platform(0, cy, 400));
    cx += 400;

    while(cx < length) {
        cx += 50 + Math.random() * gapSize;
        let hChange = (Math.random() - 0.5) * 200;
        cy += hChange;
        if(cy > GAME.height - 50) cy = GAME.height - 100;
        if(cy < 200) cy = 300;

        let w = 100 + Math.random() * 200;
        entities.platforms.push(new Platform(cx, cy, w));

        if(Math.random() > 0.5) {
            entities.decorations.push({x: cx, y: cy - 200, type: 'staff'});
        }

        if(Math.random() < enemyChance) {
            entities.enemies.push(new Enemy(cx + w/2, cy - 35));
        }

        if(Math.random() < 0.5) {
            let noteY = cy - 80 - Math.random()*100;
            entities.collectibles.push(new Note(cx + w/2, noteY));
        }

        cx += w;
    }

    entities.goal = { x: length + 100, y: cy - 150, w: 40, h: 150 };
    entities.platforms.push(new Platform(length, cy, 300));
}

function spawnDust(x, y) {
    for(let i=0; i<5; i++) {
        entities.particles.push({
            x: x, y: y, vx: (Math.random()-0.5)*5, vy: (Math.random()-0.5)*5,
            life: 20, color: '#fff'
        });
    }
}

function hurtPlayer(dmg) {
    if(entities.player.invuln > 0) return;
    GAME.lives--;
    AudioSys.sfxHit();
    entities.player.invuln = 60;
    updateHUD();

    if(GAME.lives <= 0) {
        gameOver();
    } else {
        entities.player.vy = -10;
        if(entities.player.y > GAME.height) {
            entities.player.y = 0;
            entities.player.x = Math.max(0, entities.player.x - 200);
            entities.player.vx = 0;
        }
    }
}

function gameOver(win=false) 
